<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/p5"></script>
  </head>
  <style>
    body {
      background-color: black;
    }
  </style>

  <body>
    <script>
      let angle = 0;
      let textureImg;
      let stars = [];
      let planetSize;
      let glowSize;
      let initialRotationX;
      let initialRotationY;
      let hasRings;
      let rings = [];
      let ringSize;
      let numRingParticles;
      let numMoons;
      let moonSize;
      let moons = [];
      let moonTextures = [];

      function setup() {
        createCanvas(500, 500, WEBGL);
        let numColors = 5;
        let randomPalette = [];
        for (let i = 0; i < numColors; i++) {
          randomPalette.push(color(random(255), random(255), random(255)));
        }
        let thresholds = [];
        for (let i = 0; i < numColors - 1; i++) {
          thresholds.push(random());
        }
        thresholds.sort();
        let randomColorPalette = {
          thresholds: thresholds,
          colors: randomPalette,
        };
        textureImg = generateTexture(
          randomColorPalette.thresholds,
          randomColorPalette.colors
        );

        // Generate stars
        for (let i = 0; i < 1000; i++) {
          stars.push({
            x: random(-width * 5, width * 5),
            y: random(-height * 5, height * 5),
            z: random(width * 5),
            radius: random(0.5, 2),
          });
        }

        planetSize = random(30, 190);
        glowSize = planetSize + random(10, 20);
        initialRotationX = random(360);
        initialRotationY = 148;

        // Determine if the planet should have rings
        hasRings = random() < 0.5; // 50% chance
        numRingParticles = random(400, 1500);
        if (hasRings) {
          ringSize = random(planetSize * 1.5, planetSize * 2);
          // Generate particles for the rings
          for (let i = 0; i < numRingParticles; i++) {
            let theta = random(TWO_PI);
            let ringRadius = random(ringSize * 0.7, ringSize);
            rings.push({
              x: ringRadius * cos(theta),
              y: ringRadius * sin(theta),
              z: random(-5, 5),
              radius: random(0.1, 2),
            });
          }
        }

        // Generate moons
        numMoons = floor(random(0, 4)); // Up to 3 moons
        for (let i = 0; i < 4; i++) {
          let moonRadius = random(planetSize * 0.05, planetSize * 0.25);
          let moonDistance = random(planetSize * 1.5, planetSize * 6);
          let randomRingParticle = random(rings); // Get a random ring particle
          let moonAngle = 0; // Keep the angle between // Calculate the angle using the particle's coordinates
          let moonSpeed = random(0.0001, 0.012); // Add random speed property
          moonTextures.push(generateMoonTexture());
          moons.push({
            radius: moonRadius,
            distance: moonDistance,
            angle: moonAngle,
            speed: moonSpeed, // Add speed property to moon object
          });
        }
      }

      function generateTexture(elevationThresholds, colors) {
        let textureImg = createGraphics(1024, 512);
        textureImg.noiseSeed(random(1000));

        for (let x = 0; x < textureImg.width; x++) {
          for (let y = 0; y < textureImg.height; y++) {
            // Convert x and y to spherical coordinates
            let lon = map(x, 0, textureImg.width, 0, TWO_PI);
            let lat = map(y, 0, textureImg.height, -PI / 2, PI / 2);
            let u = (cos(lat) * cos(lon) + 1) / 2;
            let v = (cos(lat) * sin(lon) + 1) / 2;
            let elevation = textureImg.noise(u * 4, v * 4);
            let col = color(255);
            let found = false;
            for (let i = 0; i < elevationThresholds.length; i++) {
              if (elevation < elevationThresholds[i]) {
                col = lerpColor(
                  colors[i],
                  colors[i + 1],
                  (elevation - (i === 0 ? 0 : elevationThresholds[i - 1])) *
                    (1 /
                      (elevationThresholds[i] -
                        (i === 0 ? 0 : elevationThresholds[i - 1])))
                );
                found = true;
                break;
              }
            }
            if (!found) {
              col = colors[colors.length - 1]; // Assign the last color if elevation is greater than the last threshold
            }
            textureImg.set(x, y, col);
          }
        }
        textureImg.updatePixels();
        return textureImg;
      }

      function generateMoonTexture() {
        let textureImg = createGraphics(1024, 512);
        textureImg.noiseSeed(random(1000));

        for (let x = 0; x < textureImg.width; x++) {
          for (let y = 0; y < textureImg.height; y++) {
            let lon = map(x, 0, textureImg.width, 0, TWO_PI);
            let lat = map(y, 0, textureImg.height, -PI / 2, PI / 2);
            let u = (cos(lat) * cos(lon) + 1) / 2;
            let v = (cos(lat) * sin(lon) + 1) / 2;
            let elevation = textureImg.noise(u * 4, v * 4);
            let col = color(map(elevation, 0, 1, 20, 255));
            textureImg.set(x, y, col);
          }
        }
        textureImg.updatePixels();
        return textureImg;
      }

      function draw() {
        background(0);
        // Set up ambient light
        ambientLight(100);
        ambientMaterial(0);

        // Set up point light
        pointLight(255, 255, 255, 400, 400, 1200);

        // Draw stars
        push();
        translate(0, 0, -1200);
        for (let star of stars) {
          stroke(255);
          strokeWeight(star.radius);
          point(star.x, star.y, star.z);
        }
        pop();

        // Draw rings if the planet has them
        if (hasRings) {
          let lightPosX = 0;
          let lightPosY = -planetSize * 1.5;
          let lightPosZ = 0;
          let lightPos = createVector(lightPosX, lightPosY, lightPosZ);

          rotateY(initialRotationY + angle);
          rotateX(HALF_PI);
          for (let ringParticle of rings) {
            let particlePos = createVector(
              ringParticle.x,
              ringParticle.y,
              ringParticle.z
            );
            let rotatedParticlePos = particlePos.copy().rotate(-angle);
            let distToLight = rotatedParticlePos.dist(lightPos);
            let lightEffect = 1 - pow(distToLight / (planetSize * 2), 1.5);
            let particleColor = color(120, 120, 120, 255 * lightEffect);
            stroke(particleColor);
            strokeWeight(ringParticle.radius);
            point(ringParticle.x, ringParticle.y, ringParticle.z);
          }
        }

        let fixedDistance = 450;
        let maxAngle = radians(10); // Convert 5 degrees to radians
        let mouseXRatio = map(mouseX, 0, width, -maxAngle, maxAngle);
        let mouseYRatio = map(mouseY, 0, height, -maxAngle, maxAngle);
        let camX = 400 * sin(mouseYRatio);
        let camY = -100 * cos(mouseXRatio);
        let camZ = 400;
        camera(camX, camY, camZ, 0, 0, 0, 0, 1, 0);

        // Rotate planet
        rotateY(initialRotationY + angle);
        rotateX(initialRotationX + QUARTER_PI);
        rotateZ(QUARTER_PI);
        angle += 0.005;

        // Draw planet
        texture(textureImg);
        noStroke();
        sphere(planetSize);

        // Simple glow effect

        // Draw moons
        for (let moon of moons) {
          push();
          let moonOrbitRadius = moon.distance;
          let x = moonOrbitRadius * cos(moon.angle + angle);
          let z = moonOrbitRadius * sin(moon.angle + angle);
          translate(x, 0, z);
          rotateY(initialRotationY + angle); // Add this line
          rotateX(HALF_PI); // Modify this line
          texture(moonTextures[moons.indexOf(moon)]);
          sphere(moon.radius);
          pop();
          moon.angle += moon.speed; // Update the moon's angle using its speed property
        }
      }
    </script>
  </body>
</html>
