{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IPlanets.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nenum PlanetType {\n  GAS,\n  SOLID\n}\n\nstruct Settings {\n  uint256 seed;\n  uint256 planetSize;\n  bool hasRings;\n  uint256 numMoons;\n  PlanetType planetType;\n  uint256 hue;\n  bool hasWater;\n  bytes[7] vars;\n}\n"
    },
    "contracts/interfaces/IPlanetsRenderer.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"scripty.sol/contracts/scripty/IScriptyBuilder.sol\";\nimport \"./IPlanets.sol\";\n\ninterface IPlanetsRenderer {\n  function buildAnimationURI(bytes calldata vars) external view returns (bytes memory html);\n}\n"
    },
    "contracts/PlanetsRenderer.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IPlanetsRenderer.sol\";\nimport \"./interfaces/IPlanets.sol\";\n\ncontract PlanetsRenderer is IPlanetsRenderer {\n  address public immutable ethfsFileStorageAddress;\n  address public immutable scriptyBuilderAddress;\n  address public immutable scriptyStorageAddress;\n  string public etherPlanetsScriptName;\n\n  constructor(\n    address _ethfsFileStorageAddress,\n    address _scriptyBuilderAddress,\n    address _scriptyStorageAddress,\n    string memory _etherPlanetsScriptName\n  ) {\n    ethfsFileStorageAddress = _ethfsFileStorageAddress;\n    scriptyBuilderAddress = _scriptyBuilderAddress;\n    scriptyStorageAddress = _scriptyStorageAddress;\n    etherPlanetsScriptName = _etherPlanetsScriptName;\n  }\n\n  /**\n   * @notice Use Scripty to generate the final html\n   * @dev I opted for the lazy dev approach and let scripty calculate the required buffersize\n   *      This could be calculated and passed to the contract at any point prior to its use\n   *      in `getHTMLWrappedURLSafe`\n   * @param _vars - Variables to be injected\n   * @return html - as bytes\n   */\n  function buildAnimationURI(bytes calldata _vars) external view returns (bytes memory html) {\n    // To build the html I use Scripty to manage all the annoying tagging and html construction\n    // A combination of EthFS and Scripty is used for storage and this array stores the required\n    // code data\n    WrappedScriptRequest[] memory requests = new WrappedScriptRequest[](5);\n\n    // Step 1.\n    // - create custom content blocks that have no wrapper\n    // - we do this to easily inject css and dom elements\n    // - double urlencoded\n    // - first block is css + some JS\n    // - second block is coaster settings [biome + speed]\n    //\n    // Final Output:\n    // https://github.com/intartnft/scripty.sol/blob/main/contracts/scripty/ScriptyBuilder.sol#L648\n    // [double urlencoded data]\n\n    requests[0].wrapType = 4;\n    requests[0]\n      .scriptContent = \"%253Cstyle%253E%250A%2520%2520body%252C%250A%2520%2520html%2520%257B%250A%2520%2520%2520%2520overflow%253A%2520hidden%253B%250A%2520%2520%2520%2520margin%253A%25200%253B%250A%2520%2520%2520%2520width%253A%2520100%2525%253B%250A%2520%2520%2520%2520height%253A%2520100%2525%253B%250A%2520%2520%257D%250A%2520%2520body%2520%257B%250A%2520%2520%2520%2520background-color%253A%2520black%253B%250A%2520%2520%257D%250A%253C%252Fstyle%253E\";\n\n    // Step 2.\n    // - wrap the JS variables in <script>\n    // - no name is needed as we are injected the code rather than\n    //   pulling it from a contract (scriptyStorage/EthFS)\n    // - wrapType 1 w/ script content\n    //\n    //\n    // Final Output:\n    // https://github.com/intartnft/scripty.sol/blob/main/contracts/scripty/ScriptyBuilder.sol#L638\n    // <script src=\"data:text/javascript;base64,[vars]\"></script>\n\n    requests[1].name = \"\";\n    requests[1].wrapType = 1;\n    requests[1].scriptContent = _vars;\n\n    // Step 3.\n    // - pull the gzipped p5 lib from EthFS\n    // - wrapType 2 will handle the gzip script wrappers\n    //\n    // Final Output:\n    // https://github.com/intartnft/scripty.sol/blob/main/contracts/scripty/ScriptyBuilder.sol#L642\n    // <script type=\"text/javascript+gzip\" src=\"data:text/javascript;base64,[p5-v1.5.0.min.js.gz]\"></script>\n\n    requests[2].name = \"p5-v1.5.0.min.js.gz\";\n    requests[2].wrapType = 2;\n    requests[2].contractAddress = ethfsFileStorageAddress;\n\n    // Step 4.\n    // - pull the coaster code from scriptyStorage\n    //   I could have stored on EthFS, but wanted to show that pulling from\n    //   another contract is possible.\n    // - wrapType 2 will handle the gzip script wrappers\n    //\n    // Final Output:\n    // https://github.com/intartnft/scripty.sol/blob/main/contracts/scripty/ScriptyBuilder.sol#L642\n    // <script type=\"text/javascript+gzip\" src=\"data:text/javascript;base64,[cryptoCoaster.min.js.gz]\"></script>\n\n    requests[3].name = etherPlanetsScriptName;\n    requests[3].wrapType = 2;\n    requests[3].contractAddress = scriptyStorageAddress;\n\n    // Step 4.\n    // - pull the gunzip handler from EthFS\n    // - wrapType 1 will handle the script tags\n    //\n    // Final Output:\n    // https://github.com/intartnft/scripty.sol/blob/main/contracts/scripty/ScriptyBuilder.sol#L638\n    // <script src=\"data:text/javascript;base64,[gunzipScripts-0.0.1.js]\"></script>\n\n    requests[4].name = \"gunzipScripts-0.0.1.js\";\n    requests[4].wrapType = 1;\n    requests[4].contractAddress = ethfsFileStorageAddress;\n\n    IScriptyBuilder IScriptyBuilder_ = IScriptyBuilder(scriptyBuilderAddress);\n    uint256 bufferSize = IScriptyBuilder_.getBufferSizeForURLSafeHTMLWrapped(requests);\n    return IScriptyBuilder_.getHTMLWrappedURLSafe(requests, bufferSize);\n  }\n}\n"
    },
    "scripty.sol/contracts/scripty/IScriptyBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n///////////////////////////////////////////////////////////\n// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //\n// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //\n// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //\n// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //\n// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //\n// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //\n///////////////////////////////////////////////////////////\n\n// =============================================================\n//                            STRUCTS\n// =============================================================\n\nstruct WrappedScriptRequest {\n    string name;\n    address contractAddress;\n    bytes contractData;\n    uint8 wrapType;\n    bytes wrapPrefix;\n    bytes wrapSuffix;\n    bytes scriptContent;\n}\n\nstruct InlineScriptRequest {\n    string name;\n    address contractAddress;\n    bytes contractData;\n    bytes scriptContent;\n}\n\ninterface IScriptyBuilder {\n\n    // =============================================================\n    //                            ERRORS\n    // =============================================================\n\n    /**\n     * @notice Error for, Invalid length of requests\n     */\n    error InvalidRequestsLength();\n\n    // =============================================================\n    //                      RAW HTML GETTERS\n    // =============================================================\n\n    /**\n     * @notice Get requested scripts housed in <body> with custom wrappers\n     * @dev Your requested scripts are returned in the following format:\n     *      <html>\n     *          <head></head>\n     *          <body style='margin:0;'>\n     *              [wrapPrefix[0]]{request[0]}[wrapSuffix[0]]\n     *              [wrapPrefix[1]]{request[1]}[wrapSuffix[1]]\n     *              ...\n     *              [wrapPrefix[n]]{request[n]}[wrapSuffix[n]]\n     *          </body>\n     *      </html>\n     * @param requests - Array of WrappedScriptRequests\n     * @param bufferSize - Total buffer size of all requested scripts\n     * @return Full html wrapped scripts\n     */\n    function getHTMLWrapped(\n        WrappedScriptRequest[] calldata requests,\n        uint256 bufferSize\n    ) external view returns (bytes memory);\n\n    /**\n     * @notice Get requested scripts housed in URL Safe wrappers\n     * @dev Any wrapper type 0 scripts are converted to base64 and wrapped\n     *      with <script src=\"data:text/javascript;base64,[SCRIPT]\"></script>\n     *\n     *      [WARNING]: Large non-base64 libraries that need base64 encoding\n     *      carry a high risk of causing a gas out. Highly advised to use\n     *      base64 encoded scripts where possible\n     *\n     *      Your requested scripts are returned in the following format:\n     *      <html>\n     *          <head></head>\n     *          <body style='margin:0;'>\n     *              [wrapPrefix[0]]{request[0]}[wrapSuffix[0]]\n     *              [wrapPrefix[1]]{request[1]}[wrapSuffix[1]]\n     *              ...\n     *              [wrapPrefix[n]]{request[n]}[wrapSuffix[n]]\n     *          </body>\n     *      </html>\n     * @param requests - Array of WrappedScriptRequests\n     * @param bufferSize - Total buffer size of all requested scripts\n     * @return Full URL Safe wrapped scripts\n     */\n    function getHTMLWrappedURLSafe(\n        WrappedScriptRequest[] calldata requests,\n        uint256 bufferSize\n    ) external view returns (bytes memory);\n\n    /**\n     * @notice Get requested scripts housed in <body> all wrapped in <script></script>\n     * @dev Your requested scripts are returned in the following format:\n     *      <html>\n     *          <head></head>\n     *          <body style='margin:0;'>\n     *              <script>\n     *                  {request[0]}\n     *                  {request[1]}\n     *                  ...\n     *                  {request[n]}\n     *              </script>\n     *          </body>\n     *      </html>\n     * @param requests - Array of InlineScriptRequest\n     * @param bufferSize - Total buffer size of all requested scripts\n     * @return Full html wrapped scripts\n     */\n    function getHTMLInline(\n        InlineScriptRequest[] calldata requests,\n        uint256 bufferSize\n    ) external view returns (bytes memory);\n\n    // =============================================================\n    //                      ENCODED HTML GETTERS\n    // =============================================================\n\n    /**\n     * @notice Get {getHTMLWrapped} and base64 encode it\n     * @param requests - Array of WrappedScriptRequests\n     * @param bufferSize - Total buffer size of all requested scripts\n     * @return Full html wrapped scripts, base64 encoded\n     */\n    function getEncodedHTMLWrapped(\n        WrappedScriptRequest[] calldata requests,\n        uint256 bufferSize\n    ) external view returns (bytes memory);\n\n    /**\n     * @notice Get {getHTMLInline} and base64 encode it\n     * @param requests - Array of InlineScriptRequests\n     * @param bufferSize - Total buffer size of all requested scripts\n     * @return Full html wrapped scripts, base64 encoded\n     */\n    function getEncodedHTMLInline(\n        InlineScriptRequest[] calldata requests,\n        uint256 bufferSize\n    ) external view returns (bytes memory);\n\n    // =============================================================\n    //                      STRING UTILITIES\n    // =============================================================\n\n    /**\n     * @notice Convert {getHTMLWrapped} output to a string\n     * @param requests - Array of WrappedScriptRequests\n     * @param bufferSize - Total buffer size of all requested scripts\n     * @return {getHTMLWrapped} as a string\n     */\n    function getHTMLWrappedString(\n        WrappedScriptRequest[] calldata requests,\n        uint256 bufferSize\n    ) external view returns (string memory);\n\n    /**\n     * @notice Convert {getHTMLInline} output to a string\n     * @param requests - Array of InlineScriptRequests\n     * @param bufferSize - Total buffer size of all requested scripts\n     * @return {getHTMLInline} as a string\n     */\n    function getHTMLInlineString(\n        InlineScriptRequest[] calldata requests,\n        uint256 bufferSize\n    ) external view returns (string memory);\n\n    /**\n     * @notice Convert {getEncodedHTMLWrapped} output to a string\n     * @param requests - Array of WrappedScriptRequests\n     * @param bufferSize - Total buffer size of all requested scripts\n     *                     before encoding.\n     * @return {getEncodedHTMLWrapped} as a string\n     */\n    function getEncodedHTMLWrappedString(\n        WrappedScriptRequest[] calldata requests,\n        uint256 bufferSize\n    ) external view returns (string memory);\n\n    /**\n     * @notice Convert {getEncodedHTMLInline} output to a string\n     * @param requests - Array of InlineScriptRequests\n     * @param bufferSize - Total buffer size of all requested scripts\n     *                     before encoding.\n     * @return {getEncodedHTMLInline} as a string\n     */\n    function getEncodedHTMLInlineString(\n        InlineScriptRequest[] calldata requests,\n        uint256 bufferSize\n    ) external view returns (string memory);\n\n    // =============================================================\n    //                      OFF-CHAIN UTILITIES\n    // =============================================================\n\n    /**\n     * @notice Get the buffer size of a single inline requested code\n     * @param request - InlineScriptRequest data for code\n     * @return Buffer size as an unit256\n     */\n    function getInlineScriptSize(InlineScriptRequest memory request)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get the buffer size of a single wrapped requested code\n     * @param request - WrappedScriptRequest data for code\n     * @return Buffer size as an unit256\n     */\n    function getWrappedScriptSize(WrappedScriptRequest memory request)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get the buffer size of a single wrapped requested code\n     * @dev If the script is of wrapper type 0, we get buffer size for\n     *      base64 encoded version.\n     * @param request - WrappedScriptRequest data for code\n     * @return Buffer size as an unit256\n     */\n    function getURLSafeWrappedScriptSize(WrappedScriptRequest memory request)\n    external\n    view\n    returns (uint256);\n\n    /**\n     * @notice Get the buffer size of an array of html wrapped inline scripts\n     * @param requests - InlineScriptRequests data for code\n     * @return Buffer size as an unit256\n     */\n    function getBufferSizeForHTMLInline(InlineScriptRequest[] calldata requests)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get the buffer size of an array of html wrapped, wrapped scripts\n     * @param requests - WrappedScriptRequests data for code\n     * @return Buffer size as an unit256\n     */\n    function getBufferSizeForHTMLWrapped(\n        WrappedScriptRequest[] calldata requests\n    ) external view returns (uint256);\n\n    /**\n     * @notice Get the buffer size of an array of URL safe html wrapped scripts\n     * @param requests - WrappedScriptRequests data for code\n     * @return Buffer size as an unit256\n     */\n    function getBufferSizeForURLSafeHTMLWrapped(\n        WrappedScriptRequest[] calldata requests\n    ) external view returns (uint256);\n    \n    /**\n     * @notice Get the buffer size for encoded HTML inline scripts\n     * @param requests - InlineScriptRequests data for code\n     * @return Buffer size as an unit256\n     */\n    function getBufferSizeForEncodedHTMLInline(\n        InlineScriptRequest[] calldata requests\n    ) external view returns (uint256);\n\n    /**\n     * @notice Get the buffer size for encoded HTML inline scripts\n     * @param requests - InlineScriptRequests data for code\n     * @return Buffer size as an unit256\n     */\n    function getBufferSizeForEncodedHTMLWrapped(\n        WrappedScriptRequest[] calldata requests\n    ) external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}